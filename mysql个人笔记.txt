1.基本sql语句
use dbname；使用某一个数据库

create database dbname;创建数据库
create table tname values(字段1 数据类型，字段2 数据类型...);创建表
insert into tname values(值1)，(值2);插入记录
insert into tname(字段1，字段3) values(值1),(值2);指定字段插入数据

drop database dbname;删除数据库
drop table tname;删除表

alter table 表名 add 列名 类型 [约束条件];增加列(字段)--添加多字段用逗号隔开进行
alter table 表明 drop 列名1,列名2...;--删除列(字段)--多字段删除也用逗号隔开,无需加数据类型
alter table 表名 modify 列名 类型 [约束条件][first|after 列名];--修改列(字段)--列类型修改 
alter table 表名 change 原列名 新列名 类型 [约束条件][first|after 列名];--列名称修改

show databases;查看所有数据库
show create database dbname；查看创建数据库的语句
show engines;查看引擎；
show tables；查看所有表；
show create table tname；查看创建表的语句
select database();查看当前数据库
select * from tname where...;查看所有满足条件的记录
select 字段1，字段2，... from 表名 where...;查看所有满足条件的指定数据

*****mysql查询完整用法:
select [select选项] */字段列表 [字段别名] from 数据源 
[where 条件子句]
[group by 子句]
[having 子句]
[order by 子句]
[limit 子句];
2.数据类型
2.1数值类型
2.1.1整形: 
	int(4byte)	0~2**32-1				42亿多
	tinyint(1byte)	unsigned(0~255) signed(-128~127)	256
	smallint(2byte)	0~2**16-1				65536
	bigint(8byte)	0~2**64-1				
2.1.2浮点型:
	float(4byte,最多显示7个有效位) float(m,n) m:总位数 n:小数位位数
	double(8byte,最多显示15个有效位)
	decimal(最多显示28个有效位) decimal(m,n)
2.2字符类型:
	char	1~255 default 1	浪费存储空间，但性能高
	varchar	1~65535		节省存储空间，但性能低
	text/longtext(4G)/blob/longblob(4G)
	char/varchar/text的区别:
		1.存储方式和检索方式都不一样
    		2.数据的检索效率是：char > varchar > text
    		3.空间占用方面：
    char:存储定长数据方便，存储效率极高，必须在括号里定义长度，可以有默认值。比如char（10）,即不论存储的数据长度是否达到了10字节，都要占去10个字节空间（自动用空格填充），且在检索的时候会自动将空格隐藏掉，所以检索出来的数据记得用trim子类的函数过滤空格
    varchar：存储变长数据，但效率没有char高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格填充。如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。
    text：存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入
2.3枚举类型:
	enum(值1，值2...)	单选	2**16	65536
	set(值1，值2...)	多选	2**6	64
2.4时间类型
	year		YYYY
	date		YYYYMMDD
	time		HHMMSS
	datetime	YYYYMMDDHHMMSS default null
	timestamp	YYYYMMDDHHMMSS default 系统当前时间
3.数据库基本操作
	创建用户
	    create user '用户名'@'IP地址' identified by '密码';
	删除用户
	    drop user '用户名'@'IP地址';
	修改用户
	    update user set user='新名' where user='原名'; flush privileges;刷新权限
	修改密码
4.索引
	索引的定义：	
		mysql中的索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、
			UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。
		建立索引会占用磁盘空间的索引文件。
	索引的类型：
	    普通索引：仅加速查询
	    唯一索引：加速查询 + 列值唯一（可以有null）
	    主键索引：加速查询 + 列值唯一 +　表中只有一个（不可以有null）
	    组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
	    全文索引：对文本的内容进行分词，进行搜索 

	索引合并：使用多个单列索引组合查询搜索
	覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖
5.mysql常用函数
	1.group_concat()
		:可以进行单字段去重！将相同的行组合起来
		语法:group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator '分隔符'])
	2.concat()
		:拼接字符串
		语法:concat(str1,str2,...)
	3.distinct()
		:多字段去重
	4.now()
		:显示当前时间
	5.char_length()
		:显示指定字符串长度
	6.date_format()
		:格式化日期
		语法:date_format(now(),'%y-%m-%d %H:%i:%s)
	7.date_add()
	  date_sub()
		:增加/减少日期时间
		语法:date_add(date,interval expr unit)
		     date_sub(date,interval expr unit)
	8.cast()
		:显示类型转换
		语法:cast(expr as type)

	
cookies:
	1.什么是分区，分表？

	2.为什么要分区，分表？
	答:我们在日常开发中不可避免的会遇到大数据量表的情况，这样的表过于庞大，导致进行数据库查询
	和更新时耗时太长，性能下降，如果有联合查询那么性能会更糟糕。所以，分区和分表的目的就是减少
	数据库的执行负担，稳定SQL性能。
	3.如何分区，分表？
	答:分表：
	    水平分割（重要）:水平分割是企业最常用到的，水平拆分就是大表按照记录分为很多子表：
    		水平分的规则完全是自定义的，有以下几种参考设计：
        	1.hash、自增id取模
        	对某个字段进行hash来确定创建几张表，并根据hash结果存入不同的表；
        	2.按时间
        	根据业务可以按照天、月、年来进行拆分；
        	3.按每个表的固定记录数
        	一般按照自增ID进行拆表，一张表的数据行到了指定的数量，就自动保存到下一张表中。
		比如规定一张表只能存1-1000个记录；
        	4.将老数据迁移到一张历史表
        	比如日志表，一般只查询3个月之内的数据，对于超过3个月的记录将之迁移到历史子表中；
	    垂直分割（并不常用）:就是将一个表按照字段来分，每张表保证有相同的主键就好。一般来说，
		将常用字段和大字段分表来放
	分表时需要的设计：
   		 查询时：要根据预定义规则查询不同的子表；
    		select/update/delete时：极有可能涉及多张表，必须在程序逻辑上的事务中都包括好所有的表。
	
	分区:
		水平分区:   有几种模式如下：
			    Range：定义范围来分
			    Hash：定义Hash来分
			    Key：Hash的一种延伸
			    List（预定义列表）：自己定义几个值来分
			    Composite（复合模式）：对1234组合使用
		垂直分区:    一般将大text和BLOB列分到另一个区
	4.join有几种，他们的作用和用法是什么？
	答: 	分为内连接:	inner join	
			 	获取两个表中有匹配关系的记录，即两表取交集
		    外连接: 	left/right join
				以左/右表为基础获取匹配关系的记录,若右表中没有匹配项,NULL表示
	5.mysql中的锁有哪些，死锁是怎么产生的？
		定义：	数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中
			就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和
			存储不正确的数据，破坏数据库的一致性。加锁是实现数据库并发控制的一个非常重要
			的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后
			事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据
			对象进行更新操作。
		共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页；
				 通常是该页被读取完毕，S锁立即被释放。 
		排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；
				X锁一直到事务结束才能被释放。 
		更新（U)锁：更新锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用
				共享锁造成的死锁现象。因为使用共享锁时，修改数据的操作分为两步，首先
				获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改
				操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改
				数据的时候，这些事务都要将共享锁升级为排它锁。这时，这些事务都不会释
				放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前
				直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。
	6.mysql的端口号: 3306

	


	




